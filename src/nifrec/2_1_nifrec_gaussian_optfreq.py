"""
File: nifrec_gaussian_optfreq.py
Author: Hideya Tanaka at Nara Institute of Science and Technology
Supervised by: Tomoyuki Miyao at Nara Institute of Science and Technology
Description:
    This script performs Gaussian 'opt freq' calculations using any 
    Gaussian-compatible method—such as HF, DFT, or MP2—while continuously 
    monitoring the vibrational frequency output.  Although it is designed 
    to import the lowest-energy structures generated by an upstream xTB 
    workflow, any user-supplied .xyz file can be treated in the same way.

    Its hallmark is a rigorous strategy for eliminating residual
    imaginary frequencies.  After an initial optimization and frequency
    calculation, the program performs an RCFC re-optimization; if negative 
    modes persist, it constructs a normalized displacement vector from either 
    the most negative mode or the sum of all imaginary modes, applies 
    successively larger scalar displacements, and repeats 'opt freq' 
    cycle until every frequency is real or a user-defined iteration limit is reached.

    File management reflects the calculation outcome.  Conformers that
    converge without imaginary frequencies have their .gjf, .log, and
    .chk files moved to dedicated success directories.  Conformers that
    retain imaginary frequencies are renamed with a descriptive suffix
    and collected in the 'imagf' directory.  If a Gaussian job terminates 
    abnormally, its files remain in the working directory and no further 
    attempts are made for that molecule; once all jobs have completed, the working 
    directory therefore contains only the failed cases, providing an immediate 
    target list for manual resubmission.
"""

import argparse
import os
import subprocess
import pandas as pd
import numpy as np
from rdkit import Chem
from rdkit.Chem import Descriptors
import cclib
from periodictable import elements
from joblib import cpu_count
import sys
from pathlib import Path


def parse_freq_and_disp(logpath):
    data = cclib.io.ccread(logpath)
    return data.vibfreqs, data.vibdisps


def detect_imag(freqs):
    return any(f < 0 for f in freqs)


def combined_imag_vector(freqs, disps, imag_vec_sum):
    idx = [i for i, f in enumerate(freqs) if f < 0]
    if imag_vec_sum:
        vec = disps[idx].sum(axis=0)
    else:
        idx = min(idx, key=lambda k: freqs[k])
        vec = disps[idx]
    norm = np.linalg.norm(vec)
    return vec / norm if norm > 1e-12 else vec


def displaced_coords(coords, vec, disp):
    return coords + vec * disp


def write_gjf(njobs, mem, gname, route_section, smiles, charge, multiplicity, xyz_data, oldchkpath=''):
    gjfpath = f'{gname}.gjf'
    with open(gjfpath, 'w') as f:
        f.write(f'%nprocshared={njobs}\n')
        f.write(f'%mem={mem}GB\n')
        if oldchkpath:
            f.write(f'%oldchk={oldchkpath}\n')
        f.write(f'%chk={gname}.chk\n')
        f.write(f'{route_section}\n\n')
        if smiles:
            f.write(f'smiles: {smiles}\n\n')
        if charge != '' and multiplicity != '':
            f.write(f'{charge} {multiplicity}\n')
        if xyz_data:
            f.write(f'{xyz_data}')
        f.write('\n')


def run_gaussian(gname):
    command = f'g16 {gname}.gjf'
    try:
        subprocess.run(command, shell=True, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError as e:
            print(f'{gname}, error during gaussian run: {e}')
            return False
    return True


def move_success_dir(gjfoutfd, logoutfd, chkoutfd, gname):
    gjffilepath = f'{gjfoutfd}/{gname}.gjf'
    logfilepath = f'{logoutfd}/{gname}.log'
    chkfilepath = f'{chkoutfd}/{gname}.chk'
    paths = [gjffilepath, logfilepath, chkfilepath]
    exts = ['.gjf', '.log', '.chk']
    
    for path, ext in zip(paths, exts):
        if os.path.exists(f'{gname}{ext}'):
            os.rename(f'{gname}{ext}', f'{path}')
        else:
            print(f'{gname}{ext} does not exist')
            return False
    return True


def move_imag_dir(imagfoutfd, gname, suffix):
    gjffilepath = f'{imagfoutfd}/{gname}_{suffix}.gjf'
    logfilepath = f'{imagfoutfd}/{gname}_{suffix}.log'
    chkfilepath = f'{imagfoutfd}/{gname}_{suffix}.chk'
    paths = [gjffilepath, logfilepath, chkfilepath]
    exts = ['.gjf', '.log', '.chk']
    
    for path, ext in zip(paths, exts):
        if os.path.exists(f'{gname}{ext}'):
            os.rename(f'{gname}{ext}', f'{path}')
        else:
            print(f'{gname}{ext} does not exist')
            return False, None, None
    return True, logfilepath, chkfilepath


def run_goptfreq_pipeline(smiles, gjfoutfd, logoutfd, chkoutfd, imagfoutfd, xtbxyzfd, filepath, level_of_theory, charge, multiplicity, mem, njobs, base_disp, max_repeat, imag_vec_sum):

    gname = filepath.replace('xTB', 'g').replace('.xyz', '')
    logpath = f'{gname}.log'

    def read_xyz(file_path):
        with open(file_path, 'r') as f:
            lines = f.readlines()
        xyz_data = ''.join(lines[2:])
        return xyz_data
    
    xtbpath = f'{xtbxyzfd}/{filepath}'
    xyz_data = read_xyz(xtbpath)
    
    # ---------- Stage 0 ---------------------------------------------------
    route_section = f'#p {level_of_theory} opt freq=noraman'
    write_gjf(njobs, mem, gname, route_section, smiles, charge, multiplicity, xyz_data)
    
    flag_rg = run_gaussian(gname)
    if not flag_rg:
        return None, False, None, None
        
    freqs_0, _ = parse_freq_and_disp(logpath)
    if not detect_imag(freqs_0):
        flag_msd = move_success_dir(gjfoutfd, logoutfd, chkoutfd, gname)
        if not flag_msd:
            return None, False, None, None
        return logpath, True, 0, None
    
    flag_mid, _, chkfilepath_0 = move_imag_dir(imagfoutfd, gname, '0')
    if not flag_mid:
        return None, False, None, None
    
    # ---------- Stage 1 (RCFC) -------------------------------------------
    route_section_rcfc = f'#p {level_of_theory} opt=RCFC freq=noraman Guess=Read Geom=AllCheck'
    write_gjf(njobs, mem, gname, route_section_rcfc, '', '', '', '', chkfilepath_0)
    
    flag_rg = run_gaussian(gname)
    if not flag_rg:
        return None, False, None, None
        
    freqs_1, disps_1 = parse_freq_and_disp(logpath)
    if not detect_imag(freqs_1):
        flag_msd = move_success_dir(gjfoutfd, logoutfd, chkoutfd, gname)
        if not flag_msd:
            return None, False, None, None
        return logpath, True, 1, None
    
    flag_mid, logfilepath_1, _ = move_imag_dir(imagfoutfd, gname, '1')
    if not flag_mid:
        return None, False, None, None
    
    # ---------- Stage 2 (displacement loop) ------------------------------
    data_imagf = cclib.io.ccread(logfilepath_1)
    coords_imagf = data_imagf.atomcoords[-1]
    atomnos_imagf = data_imagf.atomnos
    symbols_imagf = [elements[Z].symbol for Z in atomnos_imagf]

    vec = combined_imag_vector(freqs_1, disps_1, imag_vec_sum)
    for i in range(max_repeat):
        disp = base_disp * (i + 1)
        coords = displaced_coords(coords_imagf, vec, disp)
        xyz_data_i = '\n'.join(
            f'{sym} {x:.6f} {y:.6f} {z:.6f}'
            for sym, (x, y, z) in zip(symbols_imagf, coords)
        ) + '\n'

        write_gjf(njobs, mem, gname, route_section, smiles, charge, multiplicity, xyz_data_i)
        
        flag_rg = run_gaussian(gname)
        if not flag_rg:
            return None, False, None, None
            
        freqs_2, _ = parse_freq_and_disp(logpath)
        if not detect_imag(freqs_2):
            flag_msd = move_success_dir(gjfoutfd, logoutfd, chkoutfd, gname)
            if not flag_msd:
                return None, False, None, None
            return logpath, True, 2, i
        
        flag_mid, _, _ = move_imag_dir(imagfoutfd, gname, f'2_{i}')
        if not flag_mid:
            return None, False, None, None
    return None, False, None, -1


def process_rows_for_goptfreq(outfd, infd, infile, keyword, level_of_theory, mem, njobs, base_disp=0.1, max_repeat=5, imag_vec_sum=True):
    print(f'Gaussian calculation (opt freq)')
    print('========== Settings ==========')
    print(f'outfolder-gaussian: {outfd}')
    print(f'infolder-xtb: {infd}')
    print(f'infile: {infile}')
    print(f'suffix: {keyword}')
    print(f'theory-level: {level_of_theory}')
    print(f'nproc: {njobs}')
    print(f'mem: {mem}')
    print(f'base-disp: {base_disp}')
    print(f'max-repeat: {max_repeat}')
    print(f'imag-vec: {imag_vec_sum}')
    print('------------------------------')
    
    file_path_input = f'{infd}/{infile}'
    xtbxyzfd = f'{infd}/xtbopt_emin_xyz'
    file_path_output = f'{outfd}/gaussian_{keyword}_stats.csv'

    outputoutfd = f'{outfd}/gaussian_working_{keyword}'
    gjfoutfd = f'{outfd}/gaussian_gjf_{keyword}'
    logoutfd = f'{outfd}/gaussian_log_{keyword}'
    chkoutfd = f'{outfd}/gaussian_chk_{keyword}'
    imagfoutfd = f'{outfd}/gaussian_imagf_{keyword}'
    for path in (outfd, outputoutfd, gjfoutfd, logoutfd, chkoutfd, imagfoutfd):
        os.makedirs(path)
    
    pwd_prev = os.getcwd()
    os.chdir(outputoutfd) # Output files are stored in outputoutfd
        
    df = pd.read_csv(file_path_input, index_col=0)
    print(f'All molecules in the dataset {len(df)}')
    df = df[df['confid'] != 0]
    print(f'All molecules successfully processed by xTB opt and freq calculations {len(df)}')

    smicol = 'smiles'
    molcol = 'romol'
    df[molcol] = df[smicol].apply(Chem.MolFromSmiles)
    df.dropna(subset=molcol, inplace=True) # Drop fail molecules by RDKit
    df['formal_charge'] = df[molcol].apply(Chem.GetFormalCharge)
    df['multiplicity'] = df[molcol].apply(lambda mol: Descriptors.NumRadicalElectrons(mol) + 1)

    # Parallel calculation setting
    njobs = cpu_count() -1 if njobs < 1 else njobs

    ntotal = len(df)
    status_dict = dict()
    for worker_id, row in enumerate(df.itertuples(index=True)):
        
        number = row.Index
        smiles = row.smiles
        confid = row.confid
        energy_xtb = row.total_energy_xTB
        filepath  = row.filepath
        charge = row.formal_charge
        multiplicity = row.multiplicity
        
        with open(f'{outfd}/log_gaussian_worker_{keyword}.txt', 'w') as f:
            print(f'Processing {worker_id+1}/{ntotal}, number {number}, smiles {smiles}', file=f)
            
        logpath, is_success, success_stage, success_disploop = run_goptfreq_pipeline(smiles, gjfoutfd, logoutfd, chkoutfd, imagfoutfd, xtbxyzfd, filepath, level_of_theory, charge, multiplicity, mem, njobs, base_disp, max_repeat, imag_vec_sum)

        if is_success:
            status_dict[number] = {'smiles': smiles,
                                    'confid': confid,
                                    'charge': charge,
                                    'multiplicity': multiplicity,
                                    'total_energy_xTB': energy_xtb,
                                    'filepath': logpath,
                                    'success_stage': success_stage,
                                    'success_disploop': success_disploop}
        else:
            status_dict[number] = {'smiles': smiles,
                                    'confid': 0,
                                    'charge': charge,
                                    'multiplicity': multiplicity,
                                    'total_energy_xTB': energy_xtb,
                                    'filepath': logpath,
                                    'success_stage': success_stage,
                                    'success_disploop': success_disploop}
        
        status_df = pd.DataFrame.from_dict(status_dict, orient='index')
        status_df['success_stage'] = status_df['success_stage'].astype('Int64')
        status_df['success_disploop'] = status_df['success_disploop'].astype('Int64')
        status_df.to_csv(file_path_output)
        
    os.chdir(pwd_prev) # Set back the previous folder


def _parse_cli_args(argv=None):

    parser = argparse.ArgumentParser(
                        prog='nifrec_gaussian_optfreq',
            description=("This script performs Gaussian 'opt freq' calculations using any " 
                        "Gaussian-compatible method—such as HF, DFT, or MP2—while continuously " 
                        "monitoring the vibrational frequency output.  Although it is designed " 
                        "to import the lowest-energy structures generated by an upstream xTB " 
                        "workflow, any user-supplied .xyz file can be treated in the same way. "
                        "Its hallmark is a rigorous strategy for eliminating residual "
                        "imaginary frequencies.  After an initial optimization and frequency "
                        "calculation, the program performs an RCFC re-optimization; if negative " 
                        "modes persist, it constructs a normalized displacement vector from either " 
                        "the most negative mode or the sum of all imaginary modes, applies " 
                        "successively larger scalar displacements, and repeats 'opt freq' " 
                        "cycle until every frequency is real or a user-defined iteration limit is reached. "
                        "File management reflects the calculation outcome.  Conformers that "
                        "converge without imaginary frequencies have their .gjf, .log, and "
                        ".chk files moved to dedicated success directories.  Conformers that "
                        "retain imaginary frequencies are renamed with a descriptive suffix "
                        "and collected in the 'imagf' directory.  If a Gaussian job terminates " 
                        "abnormally, its files remain in the working directory and no further " 
                        "attempts are made for that molecule; once all jobs have completed, the working " 
                        "directory therefore contains only the failed cases, providing an immediate " 
                        "target list for manual resubmission."),
    )
    parser.add_argument('--outfolder-gaussian',
                     help="Output folder to write gaussian results (.gjf, .log, and .chk files, other logs). Accepts absolute or relative paths; '~' is expanded. The folder is created.",
                     type=str,
                     required=True,
                     )
    parser.add_argument('--infolder-xtb',
                help=("Input folder for loading xTB results (XYZ files). Accepts absolute or relative paths; '~' is expanded. "
                    "Generates .gjf files by referencing the xtbopt_emin_xyz folder located inside the specified --infolder-xtb directory."),
                     type=str,
                     required=True,
                     )
    parser.add_argument('--infile',
                     help="Name of the input CSV file (xTB summary) located under --infolder-xtb.",
                     type=str,
                     default='xTB_stats_Emin.csv',
                     )
    parser.add_argument('--suffix',
                     help='Suffix used to identify output directories and files.',
                     type=str,
                     default='optfreq',
                     )
    parser.add_argument('--theory-level',
                help=("Calculation level and additional options (in route section) for Gaussian. (e.g. 'M062X/Def2SVP') "
                    "Do not include 'opt' or 'freq' keywords, as the job will automatically run with 'opt freq=noraman'. "
                    "Use this field for other settings such as solvent effects."),
                     type=str,
                     default='M062X/Def2SVP',
                     )
    parser.add_argument('--nproc',
                     help='nprocshared in Gaussian. If <= 0, uses (CPU cores - 1).',
                     type=int,
                     default=4,
                     )
    parser.add_argument('--mem',
                     help="mem in Gaussian. It is recommended to set mem to '1-4GB * --nproc'.",
                     type=int,
                     default=16,
                     )
    parser.add_argument('--base-disp',
                help=("Initial scalar displacement (in Å) applied to the "
                    "normalized combined imaginary-mode vector to generate the first "
                    "perturbed geometry.  Subsequent iterations use integer multiples "
                    "of this value (2 * base_disp, 3 * base_disp, …).  Typical choices "
                    "are 0.05-0.20 Å: smaller values may leave the structure in the "
                    "saddle region, whereas excessively large values risk overshooting "
                    "the nearest minimum and destabilizing the optimization."),
                     type=float,
                     default=0.1,
                     )
    parser.add_argument('--max-repeat',
                help=("Positive integer that sets the upper limit on the number of "
                    "iterative displacements applied when residual imaginary frequencies "
                    "persist after the RCFC re-optimization.  Each iteration increases "
                    "the displacement magnitude by one increment of 'base_disp'."),
                     type=int,
                     default=5,
                     )
    parser.add_argument('--imag-vec',
                help=("Boolean switch that selects how the displacement vector for "
                    "imaginary-frequency nudging is built. "
                    "[True]  'sum' strategy (default): component-wise sum of all "
                    "imaginary-mode Cartesian displacement vectors, followed by L2 normalization.  "
                    "[False (if specified)]  'largest' strategy: use only the displacement vector "
                    "of the single most negative imaginary frequency, then normalize."),
                     action='store_false',
                     )
    return parser.parse_args(argv)


def main(argv=None):
    args = _parse_cli_args(argv)
    outfd = str(Path(args.outfolder_gaussian).expanduser().resolve())
    infd = str(Path(args.infolder_xtb).expanduser().resolve())
    os.makedirs(outfd)
    sys.stdout = open(f'{outfd}/log_gaussian.txt', 'w')
    process_rows_for_goptfreq(outfd, infd, args.infile, args.suffix, args.theory_level, args.mem, args.nproc, args.base_disp, args.max_repeat, args.imag_vec)
    print('Finish')
    sys.stdout.close()
    
    
if __name__ == '__main__':
    main()

    