"""
File: 2_1_nifrec_gaussian_optfreq.py
Author: Hideya Tanaka
Supervised by: Tomoyuki Miyao
Description:
    This script performs Gaussian 'opt freq' calculations using any 
    Gaussian-compatible method—such as HF, DFT, or MP2—while continuously 
    monitoring the vibrational frequency output.  Although it is designed 
    to import the lowest-energy structures generated by an upstream xTB 
    workflow, any user-supplied .xyz file can be treated in exactly the same way.

    Its hallmark is a rigorous strategy for eliminating residual
    imaginary frequencies.  After an initial optimization and frequency
    calculation, the program performs an RCFC re-optimization; if negative 
    modes persist, it constructs a normalized displacement vector from either 
    the most negative mode or the sum of all imaginary modes, applies 
    successively larger scalar displacements, and repeats 'opt freq' 
    cycle until every frequency is real or a user-defined iteration limit is reached.

    File management reflects the calculation outcome.  Conformers that
    converge without imaginary frequencies have their .gjf, .log, and
    .chk files moved to dedicated success directories.  Conformers that
    retain imaginary frequencies are renamed with a descriptive suffix
    and collected in the 'imagf' directory.  If a Gaussian job terminates 
    abnormally, its files remain in the working directory and no further 
    attempts are made for that molecule; once all jobs have completed, the working 
    directory therefore contains only the failed cases, providing an immediate 
    target list for manual resubmission.
"""

import os
import subprocess
import pandas as pd
import numpy as np
from rdkit import Chem
from rdkit.Chem import Descriptors
import cclib
from periodictable import elements
from joblib import cpu_count
import sys

def parse_freq_and_disp(logpath):
    data = cclib.io.ccread(logpath)
    return data.vibfreqs, data.vibdisps

def detect_imag(freqs):
    return any(f < 0 for f in freqs)

def combined_imag_vector(freqs, disps, imag_vec_sum):
    idx = [i for i, f in enumerate(freqs) if f < 0]
    if imag_vec_sum:
        vec = disps[idx].sum(axis=0)
    else:
        idx = min(idx, key=lambda k: freqs[k])
        vec = disps[idx]
    norm = np.linalg.norm(vec)
    return vec / norm if norm > 1e-12 else vec

def displaced_coords(coords, vec, disp):
    return coords + vec * disp

def write_gjf(njobs, mem, gname, route_section, smiles, charge, multiplicity, xyz_data, oldchkpath=''):
    gjfpath = f'{gname}.gjf'
    with open(gjfpath, 'w') as f:
        f.write(f'%nprocshared={njobs}\n')
        f.write(f'%mem={mem}GB\n')
        if oldchkpath:
            f.write(f'%oldchk={oldchkpath}\n')
        f.write(f'%chk={gname}.chk\n')
        f.write(f'{route_section}\n\n')
        if smiles:
            f.write(f'smiles: {smiles}\n\n')
        if charge != '' and multiplicity != '':
            f.write(f'{charge} {multiplicity}\n')
        if xyz_data:
            f.write(f'{xyz_data}')
        f.write('\n')

def run_gaussian(gname):
    command = f'g16 {gname}.gjf'
    try:
        subprocess.run(command, shell=True, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except subprocess.CalledProcessError as e:
            print(f'{gname}, error during gaussian run: {e}')
            return False
    return True

def move_success_dir(gjfoutfd, logoutfd, chkoutfd, gname):
    gjffilepath = f'{gjfoutfd}/{gname}.gjf'
    logfilepath = f'{logoutfd}/{gname}.log'
    chkfilepath = f'{chkoutfd}/{gname}.chk'
    paths = [gjffilepath, logfilepath, chkfilepath]
    exts = ['.gjf', '.log', '.chk']
    
    for path, ext in zip(paths, exts):
        if os.path.exists(f'{gname}{ext}'):
            os.rename(f'{gname}{ext}', f'{path}')
        else:
            print(f'{gname}{ext} does not exist')
            return False
    return True

def move_imag_dir(imagfoutfd, gname, suffix):
    gjffilepath = f'{imagfoutfd}/{gname}_{suffix}.gjf'
    logfilepath = f'{imagfoutfd}/{gname}_{suffix}.log'
    chkfilepath = f'{imagfoutfd}/{gname}_{suffix}.chk'
    paths = [gjffilepath, logfilepath, chkfilepath]
    exts = ['.gjf', '.log', '.chk']
    
    for path, ext in zip(paths, exts):
        if os.path.exists(f'{gname}{ext}'):
            os.rename(f'{gname}{ext}', f'{path}')
        else:
            print(f'{gname}{ext} does not exist')
            return False, None, None
    return True, logfilepath, chkfilepath

def run_goptfreq_pipeline(smiles, gjfoutfd, logoutfd, chkoutfd, imagfoutfd, xtbxyzfd, filepath, level_of_theory, charge, multiplicity, mem, njobs, base_disp, max_repeat, imag_vec_sum):

    gname = filepath.replace('xTB', 'g').replace('.xyz', '')
    logpath = f'{gname}.log'

    def read_xyz(file_path):
        with open(file_path, 'r') as f:
            lines = f.readlines()
        xyz_data = ''.join(lines[2:])
        return xyz_data
    
    xtbpath = f'{xtbxyzfd}/{filepath}'
    xyz_data = read_xyz(xtbpath)
    
    # ---------- Stage 0 ---------------------------------------------------
    route_section = f'#p {level_of_theory} opt freq=noraman'
    write_gjf(njobs, mem, gname, route_section, smiles, charge, multiplicity, xyz_data)
    
    flag_rg = run_gaussian(gname)
    if not flag_rg:
        return None, False, None, None
        
    freqs_0, _ = parse_freq_and_disp(logpath)
    if not detect_imag(freqs_0):
        flag_msd = move_success_dir(gjfoutfd, logoutfd, chkoutfd, gname)
        if not flag_msd:
            return None, False, None, None
        return logpath, True, 0, None
    
    flag_mid, _, chkfilepath_0 = move_imag_dir(imagfoutfd, gname, '0')
    if not flag_mid:
        return None, False, None, None
    
    # ---------- Stage 1 (RCFC) -------------------------------------------
    route_section_rcfc = f'#p {level_of_theory} opt=RCFC freq=noraman Guess=Read Geom=AllCheck'
    write_gjf(njobs, mem, gname, route_section_rcfc, '', '', '', '', chkfilepath_0)
    
    flag_rg = run_gaussian(gname)
    if not flag_rg:
        return None, False, None, None
        
    freqs_1, disps_1 = parse_freq_and_disp(logpath)
    if not detect_imag(freqs_1):
        flag_msd = move_success_dir(gjfoutfd, logoutfd, chkoutfd, gname)
        if not flag_msd:
            return None, False, None, None
        return logpath, True, 1, None
    
    flag_mid, logfilepath_1, _ = move_imag_dir(imagfoutfd, gname, '1')
    if not flag_mid:
        return None, False, None, None
    
    # ---------- Stage 2 (displacement loop) ------------------------------
    data_imagf = cclib.io.ccread(logfilepath_1)
    coords_imagf = data_imagf.atomcoords[-1]
    atomnos_imagf = data_imagf.atomnos
    symbols_imagf = [elements[Z].symbol for Z in atomnos_imagf]

    vec = combined_imag_vector(freqs_1, disps_1, imag_vec_sum)
    for i in range(max_repeat):
        disp = base_disp * (i + 1)
        coords = displaced_coords(coords_imagf, vec, disp)
        xyz_data_i = '\n'.join(
            f'{sym} {x:.6f} {y:.6f} {z:.6f}'
            for sym, (x, y, z) in zip(symbols_imagf, coords)
        ) + '\n'

        write_gjf(njobs, mem, gname, route_section, smiles, charge, multiplicity, xyz_data_i)
        
        flag_rg = run_gaussian(gname)
        if not flag_rg:
            return None, False, None, None
            
        freqs_2, _ = parse_freq_and_disp(logpath)
        if not detect_imag(freqs_2):
            flag_msd = move_success_dir(gjfoutfd, logoutfd, chkoutfd, gname)
            if not flag_msd:
                return None, False, None, None
            return logpath, True, 2, i
        
        flag_mid, _, _ = move_imag_dir(imagfoutfd, gname, f'2_{i}')
        if not flag_mid:
            return None, False, None, None
    return None, False, None, -1

def process_rows_for_goptfreq(fd, file_path_input, xtbxyzfd, file_path_output, keyword, level_of_theory, mem, njobs=-1, base_disp=0.1, max_repeat=5, imag_vec_sum=True):
    print(f'Gaussian calculation (opt freq)')
    print('========== Settings ==========')
    print(f'keyword: {keyword}')
    print(f'level_of_theory: {level_of_theory}')
    print(f'mem: {mem}')
    print(f'njobs: {njobs}')
    print(f'base_disp: {base_disp}')
    print(f'max_repeat: {max_repeat}')
    print(f'file_path_input: {file_path_input}')
    print(f'xtbxyzfd: {xtbxyzfd}')
    print(f'file_path_output: {file_path_output}')
    print('------------------------------')
    
    outfd = f'{fd}/gaussian_{keyword}'
    outputoutfd = f'{outfd}/gaussian_working_{keyword}'
    gjfoutfd = f'{outfd}/gaussian_gjf_{keyword}'
    logoutfd = f'{outfd}/gaussian_log_{keyword}'
    chkoutfd = f'{outfd}/gaussian_chk_{keyword}'
    imagfoutfd = f'{outfd}/gaussian_imagf_{keyword}'
    for path in (outfd, outputoutfd, gjfoutfd, logoutfd, chkoutfd, imagfoutfd):
        os.makedirs(path, exist_ok=True)
    
    pwd_prev = os.getcwd()
    os.chdir(outputoutfd) # Output files are stored in outputoutfd
        
    df = pd.read_csv(file_path_input, index_col=0)
    print(f'All molecules in the dataset {len(df)}')
    df = df[df['confid'] != 0]
    print(f'All molecules successfully processed by xTB opt and freq calculations {len(df)}')

    smicol = 'smiles'
    molcol = 'romol'
    df[molcol] = df[smicol].apply(Chem.MolFromSmiles)
    df.dropna(subset=molcol, inplace=True) # Drop fail molecules by RDKit
    df['formal_charge'] = df[molcol].apply(Chem.GetFormalCharge)
    df['multiplicity'] = df[molcol].apply(lambda mol: Descriptors.NumRadicalElectrons(mol) + 1)

    # Parallel calculation setting
    njobs = cpu_count() -1 if njobs < 1 else njobs

    ntotal = len(df)
    status_dict = dict()
    for worker_id, row in enumerate(df.itertuples(index=True)):
        
        number = row.Index
        smiles = row.smiles
        confid = row.confid
        energy_xtb = row.total_energy
        filepath  = row.filepath
        charge = row.formal_charge
        multiplicity = row.multiplicity
        
        with open(f'{fd}/log_gaussian_worker_{keyword}.txt', 'w') as f:
            print(f'Processing {worker_id+1}/{ntotal}, number {number}, smiles {smiles}', file=f)
            
        logpath, is_success, success_stage, success_disploop = run_goptfreq_pipeline(smiles, gjfoutfd, logoutfd, chkoutfd, imagfoutfd, xtbxyzfd, filepath, level_of_theory, charge, multiplicity, mem, njobs, base_disp, max_repeat, imag_vec_sum)

        if is_success:
            status_dict[number] = {'smiles': smiles,
                                    'confid': confid,
                                    'charge': charge,
                                    'multiplicity': multiplicity,
                                    'total_energy_xTB': energy_xtb,
                                    'filepath': logpath,
                                    'success_stage': success_stage,
                                    'success_disploop': success_disploop}
        else:
            status_dict[number] = {'smiles': smiles,
                                    'confid': 0,
                                    'charge': charge,
                                    'multiplicity': multiplicity,
                                    'total_energy_xTB': energy_xtb,
                                    'filepath': logpath,
                                    'success_stage': success_stage,
                                    'success_disploop': success_disploop}
        
        status_df = pd.DataFrame.from_dict(status_dict, orient='index')
        status_df['success_stage'] = status_df['success_stage'].astype('Int64')
        status_df['success_disploop'] = status_df['success_disploop'].astype('Int64')
        status_df.to_csv(file_path_output)
        
    os.chdir(pwd_prev) # Set back the previous folder

if __name__ == '__main__':
    fd = os.path.dirname(os.path.abspath(__file__))
    
    # ========== Settings (CHANGE HERE) ==========
    # A name used to identify output directories and files (Modification is not mandatory)
    keyword = 'optfreq'
    
    # Level of theory (e.g. 'M062X/Def2SVP')
    level_of_theory = 'M062X/Def2SVP'
    
    # %nprocshared in Gaussian
    njobs = 4
    # %mem in Gaussian
    # It is recommended to set %mem to '1-4GB × number of parallel processes'
    mem = 3 * njobs
    
    # Initial scalar displacement (in Å) applied to the
    # normalized combined imaginary-mode vector to generate the first
    # perturbed geometry.  Subsequent iterations use integer multiples
    # of this value (2 × base_disp, 3 × base_disp, …).  Typical choices
    # are 0.05–0.20 Å: smaller values may leave the structure in the
    # saddle region, whereas excessively large values risk overshooting
    # the nearest minimum and destabilizing the optimization.
    base_disp = 0.1
    
    # Positive integer that sets the upper limit on the number of
    # iterative displacements applied when residual imaginary frequencies
    # persist after the RCFC re-optimization.  Each iteration increases
    # the displacement magnitude by one increment of 'base_disp'.
    max_repeat = 5
    
    # Boolean switch that selects how the displacement vector for
    # imaginary-frequency nudging is built.
    # True  – 'sum' strategy (default): component-wise sum of all
    #         imaginary-mode Cartesian displacement vectors, followed
    #         by L2 normalization.
    # False – 'largest' strategy: use only the displacement vector
    #         of the single most negative imaginary frequency,
    #         then normalize.
    imag_vec_sum = True

    # Enter the file and directory paths
    file_path_input = f'{fd}/xTB_stats_Emin.csv'
    xtbxyzfd = f'{fd}/xTBopt_Emin_xyz'
    file_path_output = f'{fd}/gaussian_{keyword}_stats.csv'
    # =============================================
    
    sys.stdout = open(f'{fd}/log_gaussian_{keyword}.txt', 'w')
    process_rows_for_goptfreq(fd, file_path_input, xtbxyzfd, file_path_output, keyword, level_of_theory, mem, njobs, base_disp, max_repeat, imag_vec_sum)
    print('Finish')
    sys.stdout.close()

    
    